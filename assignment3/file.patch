diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index 9cc07c3..0000000
--- a/.gitignore
+++ /dev/null
@@ -1,33 +0,0 @@
-.vscode
-# Prerequisites
-*.d
-
-# Compiled Object files
-*.slo
-*.lo
-*.o
-*.obj
-
-# Precompiled Headers
-*.gch
-*.pch
-
-# Compiled Dynamic libraries
-*.so
-*.dylib
-*.dll
-
-# Fortran module files
-*.mod
-*.smod
-
-# Compiled Static libraries
-*.lai
-*.la
-*.a
-*.lib
-
-# Executables
-*.exe
-*.out
-*.app
\ No newline at end of file
diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..abae644
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,29 @@
+{
+    // Use IntelliSense to learn about possible attributes.
+    // Hover to view descriptions of existing attributes.
+    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
+    "version": "0.2.0",
+    "configurations": [
+        {
+            "name": "g++ - Build and debug active file",
+            "type": "cppdbg",
+            "request": "launch",
+            "program": "${fileDirname}/${fileBasenameNoExtension}",
+            "args": [],
+            "stopAtEntry": false,
+            "cwd": "${fileDirname}",
+            "environment": [],
+            "externalConsole": false,
+            "MIMode": "gdb",
+            "setupCommands": [
+                {
+                    "description": "Enable pretty-printing for gdb",
+                    "text": "-enable-pretty-printing",
+                    "ignoreFailures": true
+                }
+            ],
+            "preLaunchTask": "C/C++: g++ build active file",
+            "miDebuggerPath": "/usr/bin/gdb"
+        }
+    ]
+}
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..1bbab78
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,71 @@
+{
+  "files.associations": {
+    "string": "cpp",
+    "array": "cpp",
+    "atomic": "cpp",
+    "hash_map": "cpp",
+    "bit": "cpp",
+    "*.tcc": "cpp",
+    "cctype": "cpp",
+    "chrono": "cpp",
+    "clocale": "cpp",
+    "cmath": "cpp",
+    "compare": "cpp",
+    "concepts": "cpp",
+    "condition_variable": "cpp",
+    "csignal": "cpp",
+    "cstdarg": "cpp",
+    "cstddef": "cpp",
+    "cstdint": "cpp",
+    "cstdio": "cpp",
+    "cstdlib": "cpp",
+    "cstring": "cpp",
+    "ctime": "cpp",
+    "cwchar": "cpp",
+    "cwctype": "cpp",
+    "deque": "cpp",
+    "list": "cpp",
+    "map": "cpp",
+    "set": "cpp",
+    "unordered_map": "cpp",
+    "unordered_set": "cpp",
+    "vector": "cpp",
+    "exception": "cpp",
+    "algorithm": "cpp",
+    "functional": "cpp",
+    "iterator": "cpp",
+    "memory": "cpp",
+    "memory_resource": "cpp",
+    "numeric": "cpp",
+    "optional": "cpp",
+    "random": "cpp",
+    "ratio": "cpp",
+    "string_view": "cpp",
+    "system_error": "cpp",
+    "tuple": "cpp",
+    "type_traits": "cpp",
+    "utility": "cpp",
+    "fstream": "cpp",
+    "future": "cpp",
+    "initializer_list": "cpp",
+    "iomanip": "cpp",
+    "iosfwd": "cpp",
+    "iostream": "cpp",
+    "istream": "cpp",
+    "limits": "cpp",
+    "mutex": "cpp",
+    "new": "cpp",
+    "numbers": "cpp",
+    "ostream": "cpp",
+    "semaphore": "cpp",
+    "sstream": "cpp",
+    "stdexcept": "cpp",
+    "stop_token": "cpp",
+    "streambuf": "cpp",
+    "thread": "cpp",
+    "cinttypes": "cpp",
+    "typeinfo": "cpp",
+    "valarray": "cpp",
+    "variant": "cpp"
+  }
+}
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 0000000..05054c5
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,28 @@
+{
+    "tasks": [
+        {
+            "type": "cppbuild",
+            "label": "C/C++: g++ build active file",
+            "command": "/usr/bin/g++",
+            "args": [
+                "-fdiagnostics-color=always",
+                "-g",
+                "${file}",
+                "-o",
+                "${fileDirname}/${fileBasenameNoExtension}"
+            ],
+            "options": {
+                "cwd": "${fileDirname}"
+            },
+            "problemMatcher": [
+                "$gcc"
+            ],
+            "group": {
+                "kind": "build",
+                "isDefault": true
+            },
+            "detail": "Task generated by Debugger."
+        }
+    ],
+    "version": "2.0.0"
+}
\ No newline at end of file
diff --git a/assignment2/p.h b/assignment2/p.h
deleted file mode 100644
index 2d61efd..0000000
--- a/assignment2/p.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
-  Infix to postfix conversion in C++
-  Input Postfix expression must be in a desired format.
-  Operands and operator, both must be single character.
-  Only '+'  ,  '-'  , '*', '/' and '$' (for exponentiation)  operators are expected.
-*/
-#include <iostream>
-#include <stack>
-#include <string>
-
-using namespace std;
-
-// Function to convert Infix expression to postfix
-string InfixToPostfix(string expression);
-
-// Function to verify whether an operator has higher precedence over other
-int HasHigherPrecedence(char operator1, char operator2);
-
-// Function to verify whether a character is operator symbol or not.
-bool IsOperator(char C);
-
-// Function to verify whether a character is alphanumeric chanaracter (letter or numeric digit) or not.
-bool IsOperand(char C);
-
-int main()
-{
-    string expression;
-    cout << "Enter Infix Expression \n";
-    getline(cin, expression);
-    string postfix = InfixToPostfix(expression);
-    cout << "Output = " << postfix << "\n";
-}
-
-// Function to evaluate Postfix expression and return output
-string InfixToPostfix(string expression)
-{
-    // Declaring a Stack from Standard template library in C++.
-    stack<char> S;
-    string postfix = ""; // Initialize postfix as empty string.
-    for (int i = 0; i < expression.length(); i++)
-    {
-
-        // Scanning each character from left.
-        // If character is a delimitter, move on.
-        if (expression[i] == ' ' || expression[i] == ',')
-            continue;
-
-        // If character is operator, pop two elements from stack, perform operation and push the result back.
-        else if (IsOperator(expression[i]))
-        {
-            while (!S.empty() && S.top() != '(' && HasHigherPrecedence(S.top(), expression[i]))
-            {
-                postfix += S.top();
-                S.pop();
-            }
-            S.push(expression[i]);
-        }
-        // Else if character is an operand
-        else if (IsOperand(expression[i]))
-        {
-            postfix += expression[i];
-        }
-
-        else if (expression[i] == '(')
-        {
-            S.push(expression[i]);
-        }
-
-        else if (expression[i] == ')')
-        {
-            while (!S.empty() && S.top() != '(')
-            {
-                postfix += S.top();
-                S.pop();
-            }
-            S.pop();
-        }
-    }
-
-    while (!S.empty())
-    {
-        postfix += S.top();
-        S.pop();
-    }
-
-    return postfix;
-}
-
-// Function to verify whether a character is english letter or numeric digit.
-// We are assuming in this solution that operand will be a single character
-bool IsOperand(char C)
-{
-    if (C >= '0' && C <= '9')
-        return true;
-    if (C >= 'a' && C <= 'z')
-        return true;
-    if (C >= 'A' && C <= 'Z')
-        return true;
-    return false;
-}
-
-// Function to verify whether a character is operator symbol or not.
-bool IsOperator(char C)
-{
-    if (C == '+' || C == '-' || C == '*' || C == '/' || C == '$')
-        return true;
-
-    return false;
-}
-
-// Function to verify whether an operator is right associative or not.
-int IsRightAssociative(char op)
-{
-    if (op == '$')
-        return true;
-    return false;
-}
-
-// Function to get weight of an operator. An operator with higher weight will have higher precedence.
-int GetOperatorWeight(char op)
-{
-    int weight = -1;
-    switch (op)
-    {
-    case '+':
-    case '-':
-        weight = 1;
-    case '*':
-    case '/':
-        weight = 2;
-    case '$':
-        weight = 3;
-    }
-    return weight;
-}
-
-// Function to perform an operation and return output.
-int HasHigherPrecedence(char op1, char op2)
-{
-    int op1Weight = GetOperatorWeight(op1);
-    int op2Weight = GetOperatorWeight(op2);
-
-    // If operators have equal precedence, return true if they are left associative.
-    // return false, if right associative.
-    // if operator is left-associative, left one should be given priority.
-    if (op1Weight == op2Weight)
-    {
-        if (IsRightAssociative(op1))
-            return false;
-        else
-            return true;
-    }
-    return op1Weight > op2Weight ? true : false;
-}
diff --git a/assignment2/post.h b/assignment2/post.h
deleted file mode 100644
index e87b76e..0000000
--- a/assignment2/post.h
+++ /dev/null
@@ -1,94 +0,0 @@
-#ifndef TO_POSTFIX_H
-#define TO_POSTFIX_H
-
-#include <iostream>
-#include <sstream>
-#include "stack.h"
-
-using namespace std;
-
-bool unary_minus(const char &str, int i)
-{
-    if (i == 0 && str == '-')
-        return true;
-    else if (i == 1 && str)
-        return true;
-}
-
-string whitespace(const string &infix)
-{
-    string result = "";
-    for (int i = 0; i < infix.length(); i++)
-    {
-
-        if (infix[i] == ' ')
-            continue;
-        result += infix[i];
-    }
-
-    return result;
-}
-
-bool isOperand(const string &infix)
-{
-    // "-1 * (2 + -3 * 4) / -2"
-}
-bool isOperator(const string &infix) {}
-bool ckeck_precedence(const string &infix) {}
-bool check_unary(const string &infix) {}
-string add_space() {}
-
-string to_postfix(const string &infix)
-{
-    // "-1 * (2 + -3 * 4) / -2"
-    Stack<char> stack;
-    string postfix;
-
-    // remove white space
-    string newInfix = whitespace(infix);
-
-    for (int i = 0; i < newInfix.length(); i++)
-    {
-        // "-1*(2+-3*4)/-2"
-        check_unary(newInfix);
-    }
-}
-#endif // TO_POSTFIX_H
-
-queue<Node *> q;
-q.push(root);
-
-while (true)
-{
-
-    int length = q.size();
-
-    if (length == 0)
-    {
-        break;
-    }
-
-    int i = 0;
-
-    while (i < length)
-    {
-
-        Node *n = q.front();
-        cout << n->data << " ";
-
-        if (n->left != NULL)
-        {
-            q.push(n->left);
-        }
-
-        if (n->right != NULL)
-        {
-            q.push(n->right);
-        }
-
-        q.pop();
-        i++;
-    }
-
-    cout << endl;
-}
\ No newline at end of file
diff --git a/assignment2/queue.h b/assignment2/queue.h
index eca7708..9d18851 100644
--- a/assignment2/queue.h
+++ b/assignment2/queue.h
@@ -37,10 +37,6 @@ public:
 
   // Number of elements stored
   int size() const;
-  type &rear() const
-  {
-    return _rear->data;
-  };
 };
 
 // Implement functions below
diff --git a/assignment2/test.cpp b/assignment2/test.cpp
deleted file mode 100644
index 8082653..0000000
--- a/assignment2/test.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-#include <iostream>
-#include "stack.h"
-#include "queue.h"
-#include "tree.h"
-#include "to_postfix.h"
-
-using namespace std;
-
-int main()
-{
-
-    Stack<int> s;
-    for (int i = 0; i < 8; ++i)
-    {
-        s.push(i);
-    }
-    while (!s.empty())
-    {
-        cout << s.top() << " "; // 7 6 5 4 3 2 1 0
-        s.pop();
-    }
-    cout << endl;
-
-    Queue<int> q;
-    for (int i = 0; i < 8; ++i)
-    {
-        q.push(i);
-    }
-    while (!q.empty())
-    {
-        cout << q.front() << " "; // 0 1 2 3 4 5 6 7
-        q.pop();
-    }
-
-    cout << endl;
-
-    // string infix = "-10 +3";
-    // string infix = "10 -3";
-    // string infix = "(10+ 3)-8";
-    // string infix = "(-10* 3)+2";
-    // string infix = "(2 + 3 * 5) + 7";
-    // string infix = "-(10 * 2)";
-    // string infix = "10 + (20 + 30)";
-    // string infix = "5/(-(2+3))";
-
-    // string infix = "(-10 * 5) - 2";
-    // string infix = "(1 + 2) *( 3 * (4 + 5))";
-    // string infix = "(7 + 4) * 2-1";
-    // string infix = "-10 + 3 - 2";
-    // string infix = "-1 * (2 + -3 * 4) / -2";
-    string infix = "((2))";
-
-    string postfix = to_postfix(infix);
-    // string postfix = "1 2 + 3 4 5 + * *";
-
-    cout << postfix << endl; // -1 2 -3 4 * + * -2 /
-
-    //
-    Tree *postfix_tree = build_expression_tree(postfix);
-    postfix_tree->print(); // (/,*,-2,-1,+,null,null,null,null,2,*,null,null,-3,4)
-
-    cout << postfix_tree->eval() << endl; // -5
-}
\ No newline at end of file
diff --git a/assignment3/FlatHash.h b/assignment3/FlatHash.h
new file mode 100644
index 0000000..e9c44f9
--- /dev/null
+++ b/assignment3/FlatHash.h
@@ -0,0 +1,420 @@
+#ifndef FLATHASH_H
+#define FLATHASH_H
+
+#include <iostream>
+using namespace std;
+
+// TODO: REHASH
+// TODO: LOAD_FACTOR
+
+// TODO: REMOVE LEFT_SHIFT
+// TODO: TEST
+
+void _probing(const unsigned int key, unsigned int *local_hashtable, unsigned int size, bool isLinear);
+// Flag(hint) for overflow handling
+enum overflow_handle
+{
+  LINEAR_PROBING = 0,
+  QUADRATIC_PROBING
+};
+
+class FlatHash
+
+{
+private:
+  unsigned int *hashtable;
+  // Variable for overflow handling
+  enum overflow_handle flag;
+  // Loading factor
+  float alpha;
+  // Size of hash table
+  unsigned int table_size;
+  // Nums of keys
+  unsigned int num_of_keys;
+  unsigned int thumbstone = 1000001;
+
+public:
+  FlatHash(enum overflow_handle _flag, float _alpha);
+
+  ~FlatHash();
+
+  unsigned int hashFunction(const unsigned int key) { return key % table_size; }
+
+  unsigned int getTableSize() { return table_size; }
+
+  unsigned int getNumofKeys() { return num_of_keys; }
+
+  // Return time cost
+  int insert(const unsigned int key);
+
+  // Remove function in lecture. Return time cost
+  int remove(const unsigned int key);
+
+  // Return time cost
+  int search(const unsigned int key);
+
+  // Delete tombstones
+  void clearTombstones();
+
+  void print();
+
+  // CUSTOM
+  unsigned int *create_table(const unsigned int size);
+  int _insert(const unsigned int key, bool isLinear);
+  void check_load_factor();
+  int _remove(const unsigned int key, bool isLinear, unsigned int *index);
+  unsigned int *rehash(const int factor);
+  int _search(const unsigned int key, const bool isLinear);
+  unsigned int *shift(const unsigned int factor);
+};
+
+FlatHash::FlatHash(enum overflow_handle _flag, float _alpha)
+{
+  // Initial table size is 1000
+  // FIXME: 1000
+  table_size = 1000;
+  num_of_keys = 0;
+  flag = _flag;
+  alpha = _alpha;
+
+  hashtable = create_table(table_size);
+}
+
+FlatHash::~FlatHash()
+{
+  // Write your code
+  if (table_size != 0)
+  {
+    delete[] hashtable;
+    table_size = 0;
+  }
+}
+
+int FlatHash::insert(const unsigned int key)
+{
+  // You have to implement two overflow handling by using flag
+  // Write your code
+  int quadratic;
+  int linear;
+
+  // FLAG = QADRATIC
+  if (flag == QUADRATIC_PROBING)
+  {
+    quadratic = _insert(key, false);
+    // NOT FOUND in QUADRATIC
+    if (quadratic == 0)
+    {
+      linear = _insert(key, true);
+      // DUPLICATE
+      if (linear < 0)
+        return linear - table_size;
+
+      // LINEAR INSERT
+      check_load_factor();
+      return linear + table_size;
+    }
+    else
+    {
+      check_load_factor();
+      return quadratic;
+    }
+  }
+  else
+  { // FLAG = LINEAR
+    linear = _insert(key, true);
+
+    check_load_factor();
+    return linear;
+  }
+}
+int FlatHash::remove(const unsigned int key)
+{
+  // Write your code
+
+  int quadratic = 0;
+  int linear = 0;
+  unsigned int index = 0;
+
+  // FLAG QUADRATIC
+  if (flag == QUADRATIC_PROBING)
+  {
+    quadratic = _remove(key, false, &index);
+    // QUADRATIC FAILED
+    if (quadratic == 0)
+    {
+      // LINEAR
+      linear = _remove(key, true, &index);
+      // TODO: LEFT SHIFT @88
+      // LINEAR FOUND
+      if (linear > 0)
+      {
+        hashtable = shift(index);
+        return linear + table_size;
+      }
+      // BOTH QUADRATIC & LINEAR TILL LAST FAILED
+      if (linear == 0)
+      {
+        int temp = -2 * table_size;
+        return temp;
+      }
+      // LINEAR KEY NOT FOUND / REACHED EMPTY BUCKET
+      return linear - table_size;
+    }
+
+    return quadratic;
+  }
+
+  // FLAG LINEAR
+  linear = _remove(key, true, &index);
+  // TODO: SHIFT @88
+  if (linear > 0)
+    hashtable = shift(index);
+  if (linear == 0)
+  {
+    linear = -table_size;
+    return linear;
+  }
+
+  return linear;
+}
+
+int FlatHash::search(const unsigned int key)
+{
+  // Write your code
+  int linear = 0;
+  int quadratic = 0;
+  // QUADRATIC
+  if (flag == QUADRATIC_PROBING)
+  {
+
+    quadratic = _search(key, false);
+    // QUADRATIC FAILED
+    if (quadratic == 0)
+    {
+      // LINEAR FOUND
+      linear = _search(key, true);
+      if (linear > 0)
+        return linear + table_size;
+      // LINEAR FAILED
+      if (linear == 0)
+      {
+        return -2 * table_size;
+      }
+      return linear - table_size;
+    }
+
+    return quadratic;
+  }
+  // FLAG LINEAR
+  linear = _search(key, true);
+  if (linear == 0)
+  {
+    int temp = -table_size;
+    return temp;
+  }
+  return linear;
+}
+
+void FlatHash::clearTombstones()
+{
+  // Write your code
+  for (unsigned int i = 0; i < table_size; i++)
+  {
+    if (hashtable[i] == thumbstone)
+      hashtable[i] = 0;
+  }
+  hashtable = rehash(1);
+}
+
+void FlatHash::print()
+{
+  // Print valid key pair - (index1:key1,index2:key2)
+  // Give **NO** space between each character
+  // e.g., (1:3,3:7,5:1)
+  std::cout << "(";
+
+  // Write your code
+  string s = "";
+  for (int i = 0; i < table_size; i++)
+  {
+    if (hashtable[i] != 0)
+    {
+      s += to_string(i) + ":" + to_string(hashtable[i]) + ",";
+    }
+  }
+  string out = s.substr(0, s.size() - 1);
+  cout << out;
+
+  std::cout << ")" << std::endl;
+}
+
+void _probing(const unsigned int key, unsigned int *local_hashtable, unsigned int size, bool isLinear)
+{
+
+  unsigned int thumbstone = 1000001;
+  // QUADRATIC or LINEAR
+  for (unsigned int i = 0; i < size; i++)
+  {
+    unsigned int index = (isLinear) ? (key + i) % size : (key + i * i) % size;
+
+    if (local_hashtable[index] == 0 || local_hashtable[index] == thumbstone)
+    {
+      local_hashtable[index] = key;
+      return;
+    }
+    if (local_hashtable[index] == key)
+      return;
+  }
+
+  // QUADRATIC FAILED, LINEAR
+  for (unsigned int i = 0; i < size; i++)
+  {
+    unsigned int index = (key + i) % size;
+
+    if (local_hashtable[index] == 0 || local_hashtable[index] == thumbstone)
+    {
+      local_hashtable[index] = key;
+      return;
+    }
+    if (local_hashtable[index] == key)
+      return;
+  }
+};
+
+unsigned int *FlatHash::create_table(const unsigned int size)
+{
+  unsigned int *table = new unsigned int[size];
+  for (unsigned int i = 0; i < size; i++)
+  {
+    table[i] = 0;
+  }
+
+  return table;
+}
+
+int FlatHash::_insert(const unsigned int key, bool isLinear)
+{
+  int res = 0;
+  for (unsigned int i = 0; i < table_size; i++)
+  {
+    unsigned int index = isLinear ? hashFunction(key + i) : hashFunction(key + i * i);
+
+    if (hashtable[index] == 0 || hashtable[index] == thumbstone)
+    {
+      hashtable[index] = key;
+      num_of_keys++;
+      return i + 1;
+    }
+    if (hashtable[index] == key)
+    {
+
+      res = -i - 1;
+      return res;
+    }
+  }
+  return res;
+};
+
+void FlatHash::check_load_factor()
+{
+  float load_factor = (float)getNumofKeys() / (float)getTableSize();
+  if (load_factor >= alpha)
+  {
+    hashtable = rehash(2);
+  }
+};
+
+int FlatHash::_remove(const unsigned int key, bool isLinear, unsigned int *position)
+{
+  int res = 0;
+  for (unsigned int i = 0; i < table_size; i++)
+  {
+    unsigned int index = isLinear ? hashFunction(key + i) : hashFunction(key + i * i);
+    *position = index;
+
+    if (hashtable[index] == key)
+    {
+      hashtable[index] = thumbstone;
+      num_of_keys--;
+      return i + 1;
+    }
+    if (hashtable[index] == 0)
+    {
+      res = -i - 1;
+      return res;
+    }
+  }
+
+  return res;
+}
+
+unsigned int *FlatHash::rehash(const int factor)
+{
+  unsigned int *newTable = create_table(table_size * factor);
+  bool isLinear = (flag == LINEAR_PROBING) ? true : false;
+  for (unsigned int i = 0; i < table_size; i++)
+  {
+    if (hashtable[i] == 0 || hashtable[i] == thumbstone)
+      continue;
+
+    _probing(hashtable[i], newTable, table_size * factor, isLinear);
+  }
+
+  delete[] hashtable;
+  table_size *= factor;
+  return newTable;
+}
+
+int FlatHash::_search(const unsigned int key, const bool isLinear)
+{
+  int res = 0;
+  for (unsigned int i = 0; i < table_size; i++)
+  {
+    unsigned int index = (isLinear) ? hashFunction(key + i) : hashFunction(key + i * i);
+    if (hashtable[index] == key)
+      return i + 1;
+
+    if (hashtable[index] == 0)
+    {
+      res = -i - 1;
+      return res;
+    }
+  }
+
+  return res;
+}
+
+unsigned int *FlatHash::shift(const unsigned int index)
+{
+  unsigned int *newTable = create_table(table_size);
+  unsigned int i = index;
+
+  do
+  {
+    bool isLinear = (flag == LINEAR_PROBING) ? true : false;
+    if (hashtable[i] == 0)
+      break;
+
+    if (hashtable[i] != thumbstone)
+      _probing(hashtable[i], newTable, table_size, isLinear);
+
+    i = (i + 1) % table_size;
+  } while (index != i);
+
+  do
+  {
+
+    if (hashtable[i] == 0 || flag == LINEAR_PROBING)
+      break;
+
+    if (hashtable[i] != thumbstone)
+      _probing(hashtable[i], newTable, table_size, true);
+
+    i = (i + 1) % table_size;
+  } while (index != i);
+
+  delete[] hashtable;
+  return newTable;
+}
+
+#endif
diff --git a/assignment3/HierarchyHash.h b/assignment3/HierarchyHash.h
new file mode 100644
index 0000000..7870028
--- /dev/null
+++ b/assignment3/HierarchyHash.h
@@ -0,0 +1,231 @@
+#ifndef HIERARCHYHASH_H
+#define HIERARCHYHASH_H
+
+#include <iostream>
+#include "FlatHash.h"
+
+class HierarchyHash
+{
+private:
+  unsigned int **hashtable;
+  unsigned int thumbstone = 1000001;
+  unsigned int allocatedSize = 0;
+
+  // Variable for overflow handling
+  enum overflow_handle flag;
+  // Loading factor
+  float alpha;
+  // Size(range) of full hash table. Initially 1000
+  unsigned int table_size;
+  // Size of subhash table. Fixed by 100
+  unsigned int sub_table_size;
+  // Nums of keys
+  unsigned int num_of_keys;
+
+public:
+  HierarchyHash(enum overflow_handle _flag, float _alpha);
+
+  ~HierarchyHash();
+
+  unsigned int hashFunction(const unsigned int key) { return key % table_size; }
+
+  unsigned int getTableSize() { return table_size; }
+
+  unsigned int getNumofKeys() { return num_of_keys; }
+
+  // Return the size of allocated sub hash table
+  unsigned int getAllocatedSize() { return allocatedSize; };
+
+  // Return time cost
+  int insert(const unsigned int key);
+
+  // Return time cost
+  int remove(const unsigned int key);
+
+  // Return time cost
+  int search(const unsigned int key);
+
+  // Delete tombstones
+  void clearTombstones();
+
+  void print();
+
+  // CUSTOM
+  unsigned int *create_sub_table();
+  unsigned int **prepare_table(unsigned int tableIndex);
+  int _insert(unsigned int key, bool isLinear);
+  void check_load_factor();
+  unsigned int **rehash(const int factor);
+};
+
+HierarchyHash::HierarchyHash(enum overflow_handle _flag, float _alpha)
+{
+  // Initial map size is 1000
+  table_size = 1000;
+  // Table size is fixed to 100
+  sub_table_size = 100;
+  flag = _flag;
+  alpha = _alpha;
+
+  // Write your code
+  hashtable = new unsigned int *[10];
+}
+
+HierarchyHash::~HierarchyHash()
+{
+  // Write your code
+}
+
+int HierarchyHash::insert(const unsigned int key)
+{
+  // Write your code
+  int q;
+  int l;
+
+  // FLAG = QADRATIC
+  if (flag == QUADRATIC_PROBING)
+  {
+    q = _insert(key, false);
+    // NOT FOUND in QUADRATIC
+    if (q == 0)
+    {
+      l = _insert(key, true);
+      // DUPLICATE
+      if (l < 0)
+        return l - table_size;
+      // LINEAR INSERT
+      check_load_factor();
+      return l + table_size;
+    }
+    else
+    {
+      check_load_factor();
+      return q;
+    }
+  }
+  else
+  { // FLAG = LINEAR
+    l = _insert(key, true);
+
+    check_load_factor();
+    return l;
+  }
+}
+
+int HierarchyHash::remove(const unsigned int key)
+{
+  // Write your code
+}
+
+int HierarchyHash::search(const unsigned int key)
+{
+  // Write your code
+}
+
+void HierarchyHash::clearTombstones()
+{
+  // Write your code
+}
+
+void HierarchyHash::print()
+{
+  // Print valid key pair for each sub hash table - subtable_id:(index1:key1,index2:key2)
+  // Seperate each sub table by endl
+  // Give **NO** space between each character
+  // e.g., 0:(1:3,3:7,5:1)
+  //       1:(101:2,192:10)
+  //       9:(902:90,938:82)
+
+  // Exceptionally, keep this code only for the case there is no key in the table
+  if (getNumofKeys() == 0)
+  {
+    std::cout << "()" << std::endl;
+    return;
+  }
+
+  // Write your code
+}
+unsigned int *HierarchyHash::create_sub_table()
+{
+  allocatedSize += sub_table_size;
+  unsigned int *temp = new unsigned int[sub_table_size];
+  for (unsigned int i = 0; i < sub_table_size; i++)
+  {
+    temp[i] = 0;
+  }
+  return temp;
+};
+
+unsigned int **HierarchyHash::prepare_table(unsigned int tableIndex)
+{
+
+  if (hashtable[tableIndex])
+  {
+    // TODO: CHECK
+    cout << "Hashtable[" << tableIndex << "]" << endl;
+    return hashtable;
+  }
+
+  hashtable[tableIndex] = create_sub_table();
+  return hashtable;
+};
+
+int HierarchyHash::_insert(unsigned int key, bool isLinear)
+{
+  for (unsigned int i = 0; i < table_size; i++)
+  {
+    unsigned int index = (isLinear) ? hashFunction(key + i) : hashFunction(key + i * i);
+    unsigned int row = index / sub_table_size;
+    unsigned int col = index % sub_table_size;
+
+    hashtable = prepare_table(row);
+    cout << hashtable[row][col] << endl;
+    if (hashtable[row][col] == 0 || hashtable[row][col] == thumbstone)
+    {
+      num_of_keys++;
+      hashtable[row][col] = key;
+      return i + 1;
+    }
+    if (hashtable[row][col] == key)
+    {
+      int res = -i - 1;
+      return res;
+    }
+    // FIXME: COUT
+    cout << hashtable[row][col] << endl;
+  }
+  return 0;
+};
+
+void HierarchyHash::check_load_factor()
+{
+  float load_factor = (float)getNumofKeys() / (float)getAllocatedSize();
+  if (load_factor >= alpha)
+  {
+    hashtable = rehash(2);
+  }
+};
+
+unsigned int **HierarchyHash::rehash(const int factor)
+{
+  bool isLinear = (flag == LINEAR_PROBING) ? true : false;
+  for (int i = 0; i < factor; i++)
+  {
+    unsigned int *newSubTable = create_sub_table();
+  }
+
+  for (unsigned int row = 0; row < 10; row++)
+  {
+    for (unsigned int col = 0; col < sub_table_size; col++)
+    {
+      if (hashtable[row][col] == 0 || hashtable[row][col] == thumbstone)
+        continue;
+      // _probing(hashtable[i], newSubTable, table_size * factor, isLinear);
+    }
+  }
+
+  // delete[] hashtable;
+  // table_size *= factor;
+  // return newTable;
+}
+#endif
diff --git a/assignment3/Makefile b/assignment3/Makefile
new file mode 100644
index 0000000..f64a469
--- /dev/null
+++ b/assignment3/Makefile
@@ -0,0 +1,6 @@
+CXXFLAGS += -Wall -std=c++11 -O3
+assign3: main.cpp FlatHash.h HierarchyHash.h NRKFlat.h
+	g++ -o assign3 $^ $(CXXFLAGS)
+
+clean:
+	$(RM) main *.o
diff --git a/assignment3/NRKFlat.h b/assignment3/NRKFlat.h
new file mode 100644
index 0000000..972e198
--- /dev/null
+++ b/assignment3/NRKFlat.h
@@ -0,0 +1,171 @@
+#ifndef NRKFLAT_H
+#define NRKFLAT_H
+
+#include "FlatHash.h"
+#include <iostream>
+#include <stdint.h>
+
+#define INT2VOIDP(i) (void *)(uintptr_t)(i)
+
+class NRKFlat : public FlatHash
+{
+private:
+  // Counter array
+  unsigned int *counters;
+  // Size of NRK filter (the number of counters)
+  unsigned int filter_size;
+
+public:
+  NRKFlat(enum overflow_handle _flag, float _alpha, unsigned int _filter_size);
+
+  ~NRKFlat();
+
+  unsigned int hashFunction(const unsigned int key) { return key % filter_size; }
+
+  // Hash function
+  unsigned int murmurHash2(const void *key);
+
+  void getMMHashValue(const unsigned int key, unsigned int &h1, unsigned int &h2, unsigned int &h3);
+
+  bool filter(const unsigned int key);
+
+  // Overwriting
+  int insert(const unsigned int key);
+
+  // Overwriting
+  int remove(const unsigned int key);
+
+  // Overwriting
+  int search(const unsigned int key);
+};
+
+NRKFlat::NRKFlat(enum overflow_handle _flag, float _alpha, unsigned int _filter_size) : FlatHash(_flag, _alpha)
+{
+  filter_size = _filter_size;
+  // Write your code
+  counters = new unsigned int[filter_size];
+
+  for (unsigned int i = 0; i < filter_size; i++)
+  {
+    counters[i] = 0;
+  }
+}
+
+NRKFlat::~NRKFlat()
+{
+  // Write your code
+}
+
+unsigned int NRKFlat::murmurHash2(const void *key)
+{
+  int len = 4;
+  unsigned int seed = 2019;
+
+  const unsigned int m = 0x5bd1e995;
+  const int r = 24;
+
+  unsigned int h = seed ^ len;
+
+  const unsigned char *data = (const unsigned char *)key;
+
+  while (len >= 4)
+  {
+    unsigned int k = *(unsigned int *)data;
+
+    k *= m;
+    k ^= k >> r;
+    k *= m;
+
+    h *= m;
+    h ^= k;
+
+    data += 4;
+    len -= 4;
+  }
+
+  switch (len)
+  {
+  case 3:
+    h ^= data[2] << 16;
+  case 2:
+    h ^= data[1] << 8;
+  case 1:
+    h ^= data[0];
+    h *= m;
+  };
+
+  h ^= h >> 13;
+  h *= m;
+  h ^= h >> 15;
+
+  return h;
+}
+
+void NRKFlat::getMMHashValue(const unsigned int key, unsigned int &h1, unsigned int &h2, unsigned int &h3)
+{
+  // You can use h1, h2 and h3 as hashing results which you have to use to decide counter locations
+  h1 = murmurHash2(INT2VOIDP(&key));
+  h2 = murmurHash2(INT2VOIDP(&h1));
+  h3 = murmurHash2(INT2VOIDP(&h2));
+}
+
+bool NRKFlat::filter(const unsigned int key)
+{
+  // You can use h1, h2 and h3 as hashing results which you have to use to decide counter locations
+  unsigned int h1, h2, h3;
+  getMMHashValue(key, h1, h2, h3);
+
+  // Write your code
+  unsigned int c1 = counters[hashFunction(h1)];
+  unsigned int c2 = counters[hashFunction(h2)];
+  unsigned int c3 = counters[hashFunction(h3)];
+
+  return (c1 > 0 && c2 > 0 && c3 > 0);
+}
+
+int NRKFlat::insert(const unsigned int key)
+{
+  // bool exists = filter(key);
+
+  // Write your code
+  int res = FlatHash::insert(key);
+  if (res > 0)
+  {
+    unsigned int h1, h2, h3;
+    getMMHashValue(key, h1, h2, h3);
+    counters[hashFunction(h1)]++;
+    counters[hashFunction(h2)]++;
+    counters[hashFunction(h3)]++;
+  }
+
+  return res;
+}
+
+int NRKFlat::remove(const unsigned int key)
+{
+  // Write your code
+  int res = FlatHash::remove(key);
+  if (res > 0)
+  {
+    unsigned int h1, h2, h3;
+    getMMHashValue(key, h1, h2, h3);
+    counters[hashFunction(h1)]--;
+    counters[hashFunction(h2)]--;
+    counters[hashFunction(h3)]--;
+  }
+
+  return res;
+}
+
+int NRKFlat::search(const unsigned int key)
+{
+  // Write your code
+  bool exists = filter(key);
+  if (exists)
+  {
+    return FlatHash::search(key);
+  }
+  return 0;
+}
+
+#endif
diff --git a/assignment3/f.cpp b/assignment3/f.cpp
new file mode 100644
index 0000000..1251ae8
--- /dev/null
+++ b/assignment3/f.cpp
@@ -0,0 +1,124 @@
+#include "FlatHash.h"
+// #include "HierarchyHash.h"
+// #include "NRKFlat.h"
+
+#include <iostream>
+
+int main()
+{
+    // std::cout << "FlatHash test: Linear" << std::endl;
+    // FlatHash fh(LINEAR_PROBING, 0.8);
+    // std::cout << fh.insert(1) << std::endl; // 6
+    // std::cout << fh.insert(2) << std::endl; // 7
+    // std::cout << fh.insert(3) << std::endl; // 7
+    // fh.print();
+    // std::cout << fh.insert(9) << std::endl; // 6
+    // fh.print();
+    // std::cout << fh.remove(21) << std::endl; // 6
+
+    // ########################################
+    // # FlatHash test example: Linear probing
+    // ########################################
+    // std::cout << "FlatHash test: Linear" << std::endl;
+    // FlatHash fh(LINEAR_PROBING, 0.8);
+    // for (int i = 1; i < 6; i++)
+    // {
+    //     std::cout << fh.insert(i) << std::endl;
+    // }
+    // fh.print();
+    // std::cout << fh.insert(11) << std::endl; // 6
+    // std::cout << fh.insert(21) << std::endl; // 7
+    // std::cout << fh.insert(12) << std::endl; // 7
+    // fh.print();
+    // std::cout << fh.remove(11) << std::endl; // 6
+    // std::cout << fh.remove(21) << std::endl; // 6
+    // fh.print();                              // [3:3,4:1003,5:5003,6:2006,7:7,8:3006,9:6]
+    // fh.~FlatHash();
+    // std::cout << std::endl;
+
+    // // ###########################################
+    // // # FlatHash test example: Quadratic probing
+    // // ###########################################
+    std::cout << "FlatHash test: Quadratic" << std::endl;
+    FlatHash fh1(QUADRATIC_PROBING, 0.8);
+    std::cout << fh1.insert(1008) << std::endl; // 1
+    std::cout << fh1.insert(8009) << std::endl; // 1
+    std::cout << fh1.insert(5008) << std::endl; // 3
+    std::cout << fh1.insert(6008) << std::endl; // 4
+    std::cout << fh1.search(9008) << std::endl; // -5
+    std::cout << fh1.insert(4009) << std::endl; // 2
+    std::cout << fh1.insert(9) << std::endl;    // 3
+    fh1.print();                                // [8:1008,9:8009,10:4009,12:5008,13:9,17:6008]
+
+    FlatHash fh2(QUADRATIC_PROBING, 0.8);
+    int a = 1;
+    for (int i = 0; i < 157; i++)
+    {
+        fh2.insert(a);
+        a += 1000;
+    }
+    std::cout << fh2.insert(a += 1000) << std::endl; // 247
+    std::cout << fh2.insert(a += 1000) << std::endl; // 249
+    std::cout << fh2.insert(a += 1000) << std::endl; // 1003
+    std::cout << fh2.insert(a += 1000) << std::endl; // 1004
+    //fh1.~FlatHash();
+    //fh2.~FlatHash();
+    std::cout << std::endl;
+
+    // // #############################
+    // // # HierarchyHash test example
+    // // #############################
+    // std::cout << "HierarchyHash test" << std::endl;
+    // HierarchyHash hh(LINEAR_PROBING, 0.8);
+    // std::cout << hh.insert(3) << std::endl;    // 1
+    // std::cout << hh.insert(7) << std::endl;    // 1
+    // std::cout << hh.insert(103) << std::endl;  // 1
+    // std::cout << hh.insert(903) << std::endl;  // 1
+    // std::cout << hh.insert(99) << std::endl;   // 1
+    // std::cout << hh.insert(1099) << std::endl; // 2
+    // std::cout << hh.insert(98) << std::endl;   // 1
+    // std::cout << hh.insert(1098) << std::endl; // 4
+    // std::cout << hh.search(100) << std::endl;  // -3
+    // hh.print();                                // 0:[3:3,7:7,98:98,99:99]
+    //                                            // 1:[100:1099,101:1098,103:103]
+    //                                            // 9:[903:903]
+
+    // std::cout << hh.remove(1099) << std::endl; // 2
+    // std::cout << hh.remove(2098) << std::endl; // -4
+    // hh.print();                                // 0:[3:3,7:7,98:98,99:99]
+    //                                            // 1:[100:1098,103:103]
+    //                                            // 9:[903:903]
+
+    // std::cout << hh.insert(1903) << std::endl; // 2
+    // std::cout << hh.remove(903) << std::endl;  // 1
+    // for (int i = 500; i < 1300; i++)
+    // {
+    //     hh.insert(i);
+    // }
+    // std::cout << hh.getTableSize() << std::endl;     // 2000
+    // std::cout << hh.getNumofKeys() << std::endl;     // 806
+    // std::cout << hh.getAllocatedSize() << std::endl; // 1100
+    // //hh.~HierarchyHash();
+    // std::cout << std::endl;
+
+    // // #######################
+    // // # NRKFlat test example
+    // // #######################
+    // std::cout << "NRKFlat test" << std::endl;
+    // NRKFlat nf(LINEAR_PROBING, 0.8, 1000);
+    // std::cout << nf.insert(2019) << std::endl; // 1
+    // std::cout << nf.search(3019) << std::endl; // 0
+    // for (int i = 1; i < 500; i++)
+    // { // UPDATED 191111
+    //     nf.insert(i);
+    // }
+    // std::cout << nf.insert(365) << std::endl; // -2
+    // std::cout << nf.search(222) << std::endl; // 2
+    // std::cout << nf.search(501) << std::endl; // 0
+    // //nf.~NRKFlat();
+    // std::cout << std::endl;
+
+    // std::cout << "done" << std::endl;
+
+    // return 0;
+}
diff --git a/assignment3/h.cpp b/assignment3/h.cpp
new file mode 100644
index 0000000..2ee2bb0
--- /dev/null
+++ b/assignment3/h.cpp
@@ -0,0 +1,46 @@
+
+#include "HierarchyHash.h"
+
+#include <iostream>
+
+int main()
+{
+
+    // #############################
+    // # HierarchyHash test example
+    // #############################
+    std::cout << "HierarchyHash test" << std::endl;
+    HierarchyHash hh(LINEAR_PROBING, 0.8);
+    std::cout << hh.insert(3) << std::endl;    // 1
+    std::cout << hh.insert(7) << std::endl;    // 1
+    std::cout << hh.insert(103) << std::endl;  // 1
+    std::cout << hh.insert(903) << std::endl;  // 1
+    std::cout << hh.insert(99) << std::endl;   // 1
+    std::cout << hh.insert(1099) << std::endl; // 2
+    std::cout << hh.insert(98) << std::endl;   // 1
+    std::cout << hh.insert(1098) << std::endl; // 4
+    std::cout << hh.search(100) << std::endl;  // -3
+    hh.print();                                // 0:[3:3,7:7,98:98,99:99]
+                                               // 1:[100:1099,101:1098,103:103]
+                                               // 9:[903:903]
+
+    std::cout << hh.remove(1099) << std::endl; // 2
+    std::cout << hh.remove(2098) << std::endl; // -4
+    hh.print();                                // 0:[3:3,7:7,98:98,99:99]
+                                               // 1:[100:1098,103:103]
+                                               // 9:[903:903]
+
+    std::cout << hh.insert(1903) << std::endl; // 2
+    std::cout << hh.remove(903) << std::endl;  // 1
+    for (int i = 500; i < 1300; i++)
+    {
+        hh.insert(i);
+    }
+    std::cout << hh.getTableSize() << std::endl;     // 2000
+    std::cout << hh.getNumofKeys() << std::endl;     // 806
+    std::cout << hh.getAllocatedSize() << std::endl; // 1100
+    //hh.~HierarchyHash();
+    std::cout << std::endl;
+
+    return 0;
+}
diff --git a/assignment3/main.cpp b/assignment3/main.cpp
new file mode 100644
index 0000000..b57927c
--- /dev/null
+++ b/assignment3/main.cpp
@@ -0,0 +1,113 @@
+#include "FlatHash.h"
+#include "HierarchyHash.h"
+#include "NRKFlat.h"
+
+#include <iostream>
+
+int main()
+{
+	// ########################################
+	// # FlatHash test example: Linear probing
+	// ########################################
+	std::cout << "FlatHash test: Linear" << std::endl;
+	FlatHash fh(LINEAR_PROBING, 0.8);
+	std::cout << fh.insert(3) << std::endl;	   // 1
+	std::cout << fh.insert(7) << std::endl;	   // 1
+	std::cout << fh.insert(7) << std::endl;	   // -1
+	std::cout << fh.insert(1003) << std::endl; // 2
+	std::cout << fh.insert(2006) << std::endl; // 1
+	std::cout << fh.insert(3006) << std::endl; // 3
+	fh.print();								   // [3:3,4:1003,6:2006,7:7,8:3006]
+	std::cout << fh.insert(6) << std::endl;	   // 4
+	std::cout << fh.remove(4003) << std::endl; // -3
+	std::cout << fh.insert(5003) << std::endl; // 3
+	fh.print();								   // [3:3,4:1003,5:5003,6:2006,7:7,8:3006,9:6]
+	//fh.~FlatHash();
+	std::cout << std::endl;
+
+	// ###########################################
+	// # FlatHash test example: Quadratic probing
+	// ###########################################
+	std::cout << "FlatHash test: Quadratic" << std::endl;
+	FlatHash fh1(QUADRATIC_PROBING, 0.8);
+	std::cout << fh1.insert(1008) << std::endl; // 1
+	std::cout << fh1.insert(8009) << std::endl; // 1
+	std::cout << fh1.insert(5008) << std::endl; // 3
+	std::cout << fh1.insert(6008) << std::endl; // 4
+	std::cout << fh1.search(9008) << std::endl; // -5
+	std::cout << fh1.insert(4009) << std::endl; // 2
+	std::cout << fh1.insert(9) << std::endl;	// 3
+	fh1.print();								// [8:1008,9:8009,10:4009,12:5008,13:9,17:6008]
+
+	FlatHash fh2(QUADRATIC_PROBING, 0.8);
+	int a = 1;
+	for (int i = 0; i < 157; i++)
+	{
+		fh2.insert(a);
+		a += 1000;
+	}
+	std::cout << fh2.insert(a += 1000) << std::endl; // 247
+	std::cout << fh2.insert(a += 1000) << std::endl; // 249
+	std::cout << fh2.insert(a += 1000) << std::endl; // 1003
+	std::cout << fh2.insert(a += 1000) << std::endl; // 1004
+	fh1.~FlatHash();
+	fh2.~FlatHash();
+	std::cout << std::endl;
+
+	// #############################
+	// # HierarchyHash test example
+	// #############################
+	std::cout << "HierarchyHash test" << std::endl;
+	HierarchyHash hh(LINEAR_PROBING, 0.8);
+	std::cout << hh.insert(3) << std::endl;	   // 1
+	std::cout << hh.insert(7) << std::endl;	   // 1
+	std::cout << hh.insert(103) << std::endl;  // 1
+	std::cout << hh.insert(903) << std::endl;  // 1
+	std::cout << hh.insert(99) << std::endl;   // 1
+	std::cout << hh.insert(1099) << std::endl; // 2
+	std::cout << hh.insert(98) << std::endl;   // 1
+	std::cout << hh.insert(1098) << std::endl; // 4
+	std::cout << hh.search(100) << std::endl;  // -3
+	hh.print();								   // 0:[3:3,7:7,98:98,99:99]
+											   // 1:[100:1099,101:1098,103:103]
+											   // 9:[903:903]
+
+	std::cout << hh.remove(1099) << std::endl; // 2
+	std::cout << hh.remove(2098) << std::endl; // -4
+	hh.print();								   // 0:[3:3,7:7,98:98,99:99]
+											   // 1:[100:1098,103:103]
+											   // 9:[903:903]
+
+	std::cout << hh.insert(1903) << std::endl; // 2
+	std::cout << hh.remove(903) << std::endl;  // 1
+	for (int i = 500; i < 1300; i++)
+	{
+		hh.insert(i);
+	}
+	std::cout << hh.getTableSize() << std::endl;	 // 2000
+	std::cout << hh.getNumofKeys() << std::endl;	 // 806
+	std::cout << hh.getAllocatedSize() << std::endl; // 1100
+	//hh.~HierarchyHash();
+	std::cout << std::endl;
+
+	// #######################
+	// # NRKFlat test example
+	// #######################
+	std::cout << "NRKFlat test" << std::endl;
+	NRKFlat nf(LINEAR_PROBING, 0.8, 1000);
+	std::cout << nf.insert(2019) << std::endl; // 1
+	std::cout << nf.search(3019) << std::endl; // 0
+	for (int i = 1; i < 500; i++)
+	{ // UPDATED 191111
+		nf.insert(i);
+	}
+	std::cout << nf.insert(365) << std::endl; // -2
+	std::cout << nf.search(222) << std::endl; // 2
+	std::cout << nf.search(501) << std::endl; // 0
+	//nf.~NRKFlat();
+	std::cout << std::endl;
+
+	std::cout << "done" << std::endl;
+
+	return 0;
+}
diff --git a/assignment3/n.cpp b/assignment3/n.cpp
new file mode 100644
index 0000000..ac2bdf3
--- /dev/null
+++ b/assignment3/n.cpp
@@ -0,0 +1,28 @@
+#include "NRKFlat.h"
+
+#include <iostream>
+
+int main()
+{
+
+    // #######################
+    // # NRKFlat test example
+    // #######################
+    std::cout << "NRKFlat test" << std::endl;
+    NRKFlat nf(LINEAR_PROBING, 0.8, 1000);
+    std::cout << nf.insert(2019) << std::endl; // 1
+    std::cout << nf.search(3019) << std::endl; // 0
+    for (int i = 1; i < 500; i++)
+    { // UPDATED 191111
+        nf.insert(i);
+    }
+    std::cout << nf.insert(365) << std::endl; // -2
+    std::cout << nf.search(222) << std::endl; // 2
+    std::cout << nf.search(501) << std::endl; // 0
+    //nf.~NRKFlat();
+    std::cout << std::endl;
+
+    std::cout << "done" << std::endl;
+
+    return 0;
+}
